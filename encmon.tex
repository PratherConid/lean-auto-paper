\section{Encoding-based translation and Monomorphization}\label{subencmon}

  As mentioned in the introduction, encoding-based translation and monomorphization
  are two approaches of translating from more expressive logical systems to
  less expressive logical systems.

  The idea of encoding-based translation is to encode
  constructions in the more expressive system using function symbols in the less
  expressive system, and define the translation as a recursive function on the terms and formulas
  of the more expressive system. For example, in the dependent type theory of Coq,
  we have the type judgement relation $\Gamma \vdash x : w$, which means ``$x$ is of
  type $w$ under context $\Gamma$''. There is no direct equivalent of this
  typing relation in untyped FOL. To express the Coq type judgement in untyped FOL, 
  CoqHammer first introduces the uninterpreted FOL predicate $T(u^*, a^*)$ for
  first-order terms $u^*$ and $a^*$ translated from Coq term $u$ and atomic Coq type $a$
  (here \textit{atomic} roughly means that $a$ cannot be
  further decomposed by the translation procedure of CoqHammer). Then, a recursive function
  $\mathcal{G}_\Gamma(u, w)$ on Coq context $\Gamma$ and Coq terms $u, w$ is defined.
  The function $\mathcal{G}_\Gamma(u, w)$ translates the typing relation $\Gamma \vdash u : w$ into an untyped FOL formula,
  in which the $T$ predicate is used to express type judgements involving atomic types.
  
  Encoding-based translation has the advantage of being (almost) complete
  and straightforward to compute. However, certain features of the more expressive
  logical system must be omitted to produce translation results of reasonable size,
  which sacrifices soundness \cite{Czajka2018HammerFC}. Moreover, even with this tradeoff,
  the translation result is usually much larger than the original term.

  The idea of monomorphization is that, the proof of many propositions in the more expressive logical
  system can \textit{essentially} be conducted in the less expressive logical system. For example,
  in polymorphic HOL, given
  \begin{enumerate}
    \item The list map function $\mathsf{List.map} : \forall (\alpha \ \beta : \mathsf{U}_1). (\alpha \to \beta) \to \mathsf{List} \ \alpha \to \mathsf{List} \ \beta$
    \item Two lists of natural numbers $xs \ ys : \mathsf{List} \ \mathbb{N}$ and two functions $f \ g : \mathbb{N} \to \mathbb{N}$
    \item The premise $xs = ys \land f = g$
  \end{enumerate}
  The equality
  \begin{equation}\label{lmapphol}
    \mathsf{List.map} \ \mathbb{N} \ \mathbb{N} \ f \ xs = \mathsf{List.map} \ \mathbb{N} \ \mathbb{N} \ g \ ys
  \end{equation}
  is provable using two rewrites $xs \Rightarrow ys, f \Rightarrow g$. The crucial observation is that, although $\textsf{List.map}$ is polymorphic, the term
  $\mathsf{List.map} \ \mathbb{N} \ \mathbb{N}$ as a whole behaves just like a monomorphic function,
  therefore the rewrites can essentially be performed in monomorphic HOL. More formally,
  the formula \eqref{lmapphol} is the image of the monomorphic HOL formula $h \ f^* \ xs^* = h \ g^* \ ys^*$
  under the inter-logical-system ``substitution''
  $$\sigma := \{h \mapsto \mathsf{List.map} \ \mathbb{N} \ \mathbb{N},
    f^* \mapsto f, g^* \mapsto g, xs^* \mapsto xs, ys^* \mapsto ys\}$$
  and the rewrites $xs \Rightarrow ys, f \Rightarrow g$ in polymorphic HOL are just manifestations of the
  rewrites $xs^* \Rightarrow ys^*, f^* \Rightarrow g^*$ in monomorphic HOL.
  
  Monomorphization is sound, produces small translation results, and preserves
  term structures during translation. However, monomorphization is incomplete,
  since it is not always possible to find an appropriate formula in the less
  expressive logical system that is equivalent to the original formula
  in the more expressive logical system.

  %TODO: A more concrete example

  As mentioned in Sect. \ref{sectlean}, an user-facing Lean syntax as simple as $x + y$ corresponds to
  the complicated expression \texttt{HAdd.hAdd $\alpha \ \beta \ \gamma$ inst x y}, where \texttt{inst}
  is a potentially large expression synthesized by typeclass inference. Therefore,
  encoding-based translation may produce overly large results on common Lean expressions.
  On the other hand, our monomorphization procedure will translate the above expression
  into $h \ x^* \ y^*$, where \texttt{HAdd.hAdd $\alpha \ \beta \ \gamma$ inst}
  is ``absorbed'' into $h$ through the inter-logical-system ``substitution''.