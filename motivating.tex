\section{Motivating Examples} \label{motex}

\begin{lrbox}{\vEq} {\color{hypcolor} \verb|Eq|} \end{lrbox}
\begin{lrbox}{\vmap} {\color{hypcolor} \verb|map|} \end{lrbox}
\begin{lrbox}{\vrev} {\color{hypcolor} \verb|reverse|} \end{lrbox}
\begin{lrbox}{\vmaprev} {\color{hypcolor} \verb|map_reverse|} \end{lrbox}
\begin{lrbox}{\vrevrev} {\color{hypcolor} \verb|reverse_reverse|} \end{lrbox}

In section \ref{exabst} and \ref{exinst}, we will demonstrate the execution of our monomorphization procedure on a
concrete example. Note that both the examples and the monomorphization procedure
here are simplified. Sect. \ref{exqdet} contains discussions and more examples
to illustrate details of our monomorphization procedure.

\subsection{$\lambda_\to^*$ Abstraction} \label{exabst}

\begin{figure}
  \begin{CenteredBox}
    \lstinputlisting[style=leanHH]{LeanCode/reverse_map_pretty.inp}
  \end{CenteredBox}
  \caption{Lean4 proof state of a problem involving \textbf{List}} \label{leanlistpretty}
\end{figure}

The Lean4 proof state of the problem we will consider is shown in Figure \ref{leanlistpretty}.
The hypotheses are displayed before $\vdash$, while the goal comes after $\vdash$.
\usebox{\vmaprev} states that \usebox{\vmap} commutes with \usebox{\vrev}, and
\usebox{\vrevrev} states that \usebox{\vrev} is the inverse function of itself.
We will focus on the most important part of monomorphization, which is the
$\lambda C$ to $\text{HOL}^*$ translation. Note that the problem is already in the
$\lambda C$ fragment of Lean.

\begin{figure}
  \begin{CenteredBox}
    \lstinputlisting[style=leanHH]{LeanCode/reverse_map_explicit.inp}
  \end{CenteredBox}
  \caption{Lean4 proof state after quantifier introduction and proof by contradiction, with implicit arguments displayed.
    Note that the equality sign in figure \ref{leanlistpretty} is a syntactic sugar of
    the polymorphic function {\usebox{\vEq}} seen here}
  \label{leanlistexplicit}
\end{figure}

As a standard first step, we introduce all the $\forall$ quantifiers
of the goal into the context, and apply proof by contradiction. The resulting proof state
is shown in Figure \ref{leanlistexplicit}.
For clarity, we have displayed the implicit arguments of all the functions.

First, we focus on translating \texttt{neg\_goal} into $\text{HOL}^*$. Following the
discussion of sect. \ref{subencmon}, we would like to find an $\text{HOL}^*$ formula $\varphi$
and a ``substitution'' $\sigma$ such that the image of $\varphi$ under $\sigma$ is \texttt{neg\_goal}.
Features not allowed in $\varphi$ include polymorphic. We also want the problem to
be provable after the translation, so $\varphi$ should preserve as much information in
\texttt{neg\_goal} as possible.

Three polymorphic functions, namely \usebox{\vEq}, \usebox{\vmap} and \usebox{\vrev}, occur in the \texttt{neg\_goal}.
Although these functions are polymorphic, instances of these functions
with dependent arguments instantiated could behave like monomorphic functions.
The type constructor \texttt{List} is also not allowed in $\text{HOL}^*$, but
\texttt{List A} and \texttt{List B} behave just like $\text{HOL}^*$ type variables.
Therefore, we can choose
$$\begin{aligned}
\varphi := & \ \neg (\mathsf{EqLB} \ (\mathsf{rB} \ (\mathsf{mAB} \ f^* \ (\mathsf{rA} \ \mathit{xs}^*))) \ (\mathsf{mAB} \ f^* \ \mathit{xs}^*)) \\
\sigma := & \ \{\mathsf{EqLB} \mapsto \texttt{@Eq (List B)}, \ \ \mathsf{mAB} \mapsto \texttt{@map A B}, \\
          & \ \ \mathsf{rA} \mapsto \texttt{@reverse A}, \ \ \mathsf{rB} \mapsto \texttt{@reverse B}, \ \ f^* \mapsto \texttt{f}, \ \ \mathit{xs}^* \mapsto \texttt{xs}\}
\end{aligned}$$

In a sense, the monomorphic instances of polymorphic functions are ``abstracted'' to $\text{HOL}^*$
variables. Note that the logical rules of $\text{HOL}^*$ are not relevant to this abstraction procedure, only
the term calculus $\lambda_\to^*$ is involved. Therefore, we name this procedure $\lambda_\to^*$ \textit{abstraction}.

However, $\lambda_\to^*$ abstraction is not directly applicable to \usebox{\vmaprev} and
\usebox{\vrevrev}, because dependent arguments of polymorphic functions in them are universally
quantified. Naturally, we would like to instantiate these quantifiers to make $\lambda_\to^*$
abstraction applicable.

\subsection{Quantifier Instantiation} \label{exinst}

If we were to prove the goal manually, there are at least two ways we can proceed. We can
either first use \texttt{@map\_reverse A B} to swap the outer \texttt{reverse} with \texttt{map}, then
use \texttt{@reverse\_reverse A} to eliminate \texttt{reverse}; or, first use
\texttt{@map\_reverse A B} to swap the inner \texttt{reverse} with \texttt{map}, then
use \texttt{@reverse\_reverse B} to eliminate \texttt{reverse}. Notice how quantifiers
in the hypotheses are instantiated so that the dependent arguments of polymorphic functions
in the instantiated hypotheses match the dependent arguments of their monomorphic instances in the goal.

Quantifier instantiation in Lean-auto's monomorphization procedure is based
on a matching procedure that reflects the above observation. Given a set of formulas $S$,
the matching procedure first computes the set $M$ of monomorphic instances of polymorphic functions occurring
in $S$, then matches type-quantified formulas in $S$ with elements of $M$. For example,
given $S=$\texttt{\{@map\_reverse, @reverse\_reverse, neg\_goal\}}, the set $M$ will be
\texttt{\{@reverse A, @reverse B, @map A B, @Eq (List B)\}}, all of which collected from \texttt{neg\_goal}.
The matching procedure will preform the following matchings:

\begin{enumerate}
  \item \texttt{@Eq (List $\beta$)} in \usebox{\vmaprev} with \texttt{@Eq (List B)},
    which produces \texttt{fun $\alpha$ => @map\_reverse $\alpha$ B}
  \item \texttt{@map $\alpha$ $\beta$} in \usebox{\vmaprev} with \texttt{@map A B},
    which produces \texttt{map\_reverse A B}
  \item \texttt{@reverse $\alpha$} in \usebox{\vmaprev} with \texttt{@reverse A} and \texttt{@reverse B},
    which produces \texttt{@map\_reverse A} and \texttt{@map\_reverse B}
  \item \texttt{@reverse $\beta$} in \usebox{\vmaprev} with \texttt{@reverse A} and \texttt{@reverse B},
    which produces \texttt{fun $\alpha$ => @map\_reverse $\alpha$ A} and \texttt{fun $\alpha$ => @map\_reverse $\alpha$ B}
  \item \texttt{@Eq (List $\alpha$)} in \usebox{\vrevrev} with \texttt{@Eq (List B)},
    which produces \texttt{@reverse\_reverse B}
  \item \texttt{@reverse $\alpha$} in \usebox{\vrevrev} with \texttt{@reverse A} and \texttt{@reverse B},
    which produces \texttt{@reverse\_reverse A} and \texttt{@reverse\_reverse B}
\end{enumerate}

Since \texttt{@reverse\_reverse A}, \texttt{@reverse\_reverse B} and \texttt{@map\_reverse A B}
are present, the instances produced are already sufficient for proving the goal.
But generally speaking, the newly generated hypothesis instances and polymorphic function instances
in them can still be matched with each other (and existing instances) to produce new useful results.
% TODO: Give a concrete example taken from my graduation thesis?
Hence, the monomorphization procedure in Lean-auto uses a saturation loop which
repeats the matching procedure until either no new instances can be produced or a predefined
threshold is reached.

\subsection{Dependent Arguments are Not Static} \label{exqdet}

\begin{figure}
  \begin{CenteredBox}
    \begin{lstlisting}[style=leanHH]
|!@DFunLike.coe!| : {F : Type (max u_1 u_5)}
  → {α : outParam (Type u_1)} → {β : outParam (α → Type u_5)}
  → [self : DFunLike F α β] → F → (a : α) → β a

@DFunLike.coe (A₀ →+ B₀) A₀ (fun x => B₀) AddMonoidHom.instFunLike f₀ a 
    \end{lstlisting}
  \end{CenteredBox}
  \caption{The function \texttt{DFunLike.coe} from MathLib4 and an expression
  containing it}
  \label{dfun}
\end{figure}

A side effect of the expressiveness of $\lambda C$ is that, whether
an argument is dependent depends on how previous arguments
are instantiated. Consider the example shown in figure \ref{dfun}. The return
type \texttt{$\beta$ a} depends on the last argument \texttt{a : $\alpha$} in the signature of
\texttt{DFunLike.coe}. However, when $\beta$ is instantiated with \texttt{fun x => B$_0$}, as in the
expression at the bottom of figure \ref{dfun}, the return type \texttt{$\beta$ a} reduces to \texttt{B$_0$},
which no longer depends on the last argument. Lean-auto takes preceding arguments into
consideration when determining whether an argument is dependent, and is able to detect
that the last argument is non-dependent in the above case.

%TODO: Intricacies in Quasi-monomorphic problems
%TODO: Definitional equality