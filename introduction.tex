\section{Introduction}

  Interactive Theorem Provers (ITPs) \cite{Harrison2014HistoryOI}
  are widely used in formal mathematics and software/hardware verification. Hammers
  \cite{Blanchette2016HammeringTQ}\cite{Czajka2018HammerFC}, a type of proof automation tool for
  ITPs, utilize Automated Theorem Provers (ATPs, including SMT solvers) to automatically solve proof goals
  arising from the formalization process.  
  
  A hammer has three main components:
  premise selection, translation from the ITP's logical system to the ATP's
  logical system, and proof reconstruction from the ATP's logical system to
  the ITP's logical system. The discrepancies between logical systems of ATPs and ITPs pose
  significant challenges to translation procedures between them.
  Several popular ITPs are based on highly expressive logical systems.
  For example, Isabelle \cite{Isabelle} is based on polymorphic higher-order logic, while
  Coq \cite{CoqRefMan}, Lean4 \cite{Lean4} and Agda \cite{Agda}
  are based an even more expressive logical system called dependent type theory \cite{LambdaWithType}\cite{Coquand1988}.
  Moreover, features such as typeclasses \cite{TypeClassHaskell}, universe polymorphism \cite{UPolyCoq} and inductive types \cite{CICIndDef}
  are commonly used as extensions to the base logical system to enhance usability of the ITP.
  On the other hand, ATPs are usually based on less expressive logical systems such
  as first-order logic (FOL) \cite{CVC5}\cite{Vampire}\cite{Z3Paper}\cite{EProver} and
  higher-order logic (HOL) \cite{HOVampire}\cite{ZipperpositionMakeWork}\cite{HOEProver}.
  An overview of the logical systems relevant to our work will be given in sect. \ref{sublogsys}.
 
  There are two existing approaches for translation from more expressive
  logical systems to less expressive ones: encoding-based translation and monomorphization.
  Encoding-based translation is used in CoqHammer \cite{Czajka2018HammerFC}
  to translate Coq into untyped FOL. Monomorphization is used to
  eliminate polymorphism in Isabelle Sledgehammer \cite{Blanchette2016HammeringTQ}\cite{Paulson2012ThreeYO}.
  We found that encoding-based translation tends to produce large translation outputs
  on complex problems arising from real ITP use cases, which negatively affects the performance of ATPs.
  Therefore, we decided to use monomorphization in Lean-auto. An overview of these two
  translation methods and related discussions will be given in sect. \ref{subencmon}.

  Since ATPs have started supporting HOL in recent years \cite{HOVampire}\cite{ZipperpositionMakeWork}\cite{HOEProver},
  we decided that Lean-auto should translate Lean4 to HOL. The overall translation has
  two stages: preprocessing (sect. \ref{sectprep}) and monomorphization.
  Monomorphization itself has two stages: quantifier instantiation (sect. \ref{sectinst})
  and $\lambda_\to^*$ abstraction (sect. \ref{sectabst}). Preprocessing translates Lean4
  into dependent type theory, and monomorphization translates dependent type theory
  into HOL. The monomorphization procedure is inspired by Isabelle Sledgehammer.
  However, since Isabelle is based on HOL, which is considerably different from
  dependent type theory, the algorithm is thoroughly redesigned.
  
  We evaluate Lean-auto on three types of ATPs:
  \begin{enumerate}
    \item Native provers, or ATPs implemented in Lean4 itself. Currently, the only general-purpose
      native prover in Lean4 is Duper \cite{DuperPaper}. Note that Lean-auto is
      used as a preprocessing step in Duper (cf. sect. 5 of \cite{DuperPaper}).
      This is because Duper's core algorithm, which is based on the algorithm used
      in the higher-order prover Zipperposition \cite{ZipperpositionMakeWork}, has limited support for dependent
      type theory, and has difficulty handling Lean4 features like typeclasses.
    \item TPTP solvers. We chose Zipperposition because it supports HOL.
    \item SMT solvers. For this category, we chose Z3 and CVC5. Since SMT solvers
      still don't fully support HOL, we implemented a simple procedure
      (which is incomplete but sufficiently sound) to translate the HOL output of Lean-auto into FOL.
  \end{enumerate}

  Currently, Lean-auto only supports proof reconstruction for native provers,
  which utilizes a verified checker implemented in Lean-auto. An
  ongoing project Lean-smt\footnote{GitHub link: https://github.com/ufmg-smite/lean-smt}
  will provide support for SMT proof reconstruction in the future. For TPTP solvers,
  the verified checker in Lean-auto may be extended to support their proof reconstruction.
  % TODO: TPTP solvers can also be used as premise selection for duper, similar to Sledgehammer