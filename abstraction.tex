\section{$\lambda_\to^*$ abstraction}\label{sectabst}

\subsection{Essentially higher-order problem}

\begin{definition} Let $\sigma : V \to \mathcal{T}_C$ be a mapping.
  Define its extension $\overline{\sigma} : \mathcal{T}_C \to \mathcal{T}_C$ as
  $$\overline{\sigma}(\mathsf{U}_\ell) := \mathsf{U}_\ell$$
  $$\overline{\sigma}(x) := \sigma(x), \text{ for }x \in V$$
  $$\overline{\sigma}(M \ N) := \overline{\sigma}(M) \ \overline{\sigma}(M)$$
  $$\overline{\sigma}(\lambda x : s. M) := \lambda x : \overline{\sigma}(s). \overline{\sigma[x \mapsto x]}(M)$$
  $$\overline{\sigma}(\forall x : s. M) := \forall x : \overline{\sigma}(s). \overline{\sigma[x \mapsto x]}(M)$$
  where
  $$\sigma[u \to t](x) := \left\{\begin{aligned}
    & t & & x = u \\
    & \sigma(x) & & x \in V \backslash \{u\}
  \end{aligned}\right.$$
\end{definition}

\begin{definition} A substitution is a triple $(\Gamma, \Gamma', \sigma)$ where $\Gamma, \Gamma'$ are $\lambda C$ contexts
  and $\sigma : V \to \mathcal{T}_C$, such that for all $(u : \tau) \in \Gamma$,
  $$\Gamma' \vdash \sigma(u) : \overline{\sigma}(\tau)$$
  $\Gamma$ is called the domain of the substitution, and $\Gamma'$ is called the codomain of the substitution.
\end{definition}

\begin{theorem}
  Let $(\Gamma, \Gamma', \sigma)$ be a substitution. If $\Gamma \vdash t : s$, then $\Gamma' \vdash \overline{\sigma}(t) : \overline{\sigma}(s)$
\end{theorem}
\begin{proof} Induction on the derivation of $\Gamma \vdash t : s$, note that $\Gamma'$ and $\sigma$
  should be universally quantified in the induction hypothesis.
\end{proof}

\begin{definition} Let $\Gamma$ be a $\lambda C$ context and $t_1, t_2$ be $\lambda C$ terms.
  If variable set $M$ and substitution $(\Gamma, \Gamma', \sigma)$ satisfies
  \begin{enumerate}
    \item There exists a $\lambda C$ term $s$ such that $\Gamma' \vdash \overline{\sigma}(t_1) : s$ and $\Gamma' \vdash \overline{\sigma}(t_2) : s$
    \item $\overline{\sigma}(t_1) \cong \overline{\sigma}(t_2)$
    \item For all variables $v \in \Gamma \backslash M$, $\sigma(v) = v$
  \end{enumerate}
  Then $(\Gamma, \Gamma', \sigma)$ is called a $M$-unifier of $t_1$ and $t_2$. In the context of Lean,
  this corresponds to a unifier of $t_1$ and $t_2$ under context $\Gamma$, with $M$ as the set of metavariables.
\end{definition}

\begin{definition} $\text{HOL}^*$ is defined as $\lambda_\to^*$ augmented with the following symbols:
  \begin{enumerate}
    \item $\mathsf{Bool}$
    \item $\bot'$ and $\to'$
    \item $\forall'_t$, for each $t \in \mathcal{T}_\to^*$
  \end{enumerate}
  
  \noindent and the following derivation rules:
  $$\frac{}{\vdash \mathsf{Bool} : \mathsf{U}_1} \ \ \ \ \frac{}{\Gamma \vdash \bot' : \mathsf{Bool}}$$
  $$\frac{}{\Gamma \vdash \to' : \mathsf{Bool} \to \mathsf{Bool} \to \mathsf{Bool}} \ \ \ \
  \frac{\Gamma \vdash s : \mathsf{U}_\ell}{\Gamma \vdash \forall'_s : (s \to \mathsf{Bool}) \to \mathsf{Bool}}$$
  
  \noindent For simplicity, we use $\forall' (x : \alpha), t$ as a shorthand for $\forall'_\alpha \ (\lambda x : \alpha. t)$

  The canonical embedding $\pi : \mathcal{T}_\to^* \to \mathcal{T}_C$ of HOL into $\lambda C$ is defined as follows:
  $$\pi(\mathsf{Bool}) := \mathsf{U}_0 \ \ \ \pi(\mathsf{U}_\ell) := \mathsf{U}_\ell \ \ \
    \pi(\mathsf{U}_\ell') := \mathsf{U}_{\ell + 1}$$
  $$\pi(\bot') := \forall (\alpha : \mathsf{U}_0). \alpha \ \ \
  \pi(\to') := \lambda (p \ q : \mathsf{U}_0). \forall (x : p). q$$
  $$\pi(\forall_t') := \lambda (p : \pi(t) \to \mathsf{U}_0). \forall (x : \pi(t)). p \ x$$
  $$\pi(x) := x, \text{ for } x \in V$$
  $$\pi(M \ N) := \pi(M) \ \pi(N) \ \ \ \pi(\lambda x : s. M) := \lambda x : \pi(s). \pi(M)$$

  \noindent $\pi$ is extended to contexts via the following definition:
  $$\pi(\emptyset) := \emptyset \ \ \ \pi(\Gamma, x : \sigma) := \pi(\Gamma), x : \pi(\sigma)$$

  %TODO: Is this really equivalent to higher-order logic?

\end{definition}

\begin{theorem}\label{ceptj} Canonical embedding preserves judgement, i.e. if $\Gamma \vdash t : s$ in HOL, then
  $\pi(\Gamma) \vdash \pi(t) : \pi(s)$ in $\lambda C$ \end{theorem}
\begin{proof} Induction on the derivation rules of HOL. \end{proof}

\begin{definition} An (HOL/$\lambda C$) problem is a tuple $(\Gamma, p)$, denoted
  as $\Gamma \vdash? p$, where $\Gamma$ is a (HOL/$\lambda C$)
  context, called the hypotheses of the problem, and $p$ is an
  (HOL/$\lambda C$) term, called the goal of the problem. A $\lambda C$ problem
  $\Gamma \vdash? p$ is provable iff there exists a $\lambda C$ term $t$ such that
  $\Gamma \vdash t : p$. An HOL problem $\Gamma \vdash? p$ is provable iff there exists
  a $\lambda C$ term $t$ such that $\pi(\Gamma) \vdash t : \pi(p)$.
\end{definition}

\begin{definition} A $\lambda C$ problem $\Gamma \vdash? p$ is essentially higher-order provable (EHOP)
  iff there exists a provable HOL problem $\Gamma' \vdash? p'$ and a substitution
  $(\pi(\Gamma'), \Gamma, \sigma)$ such that $p \cong \overline{\sigma}(\pi(p'))$.
\end{definition}

\begin{theorem}
  If a $\lambda C$ problem $\Gamma \vdash? p$ is EHOP, then it is provable.
\end{theorem}
\begin{proof} By the definition of EHOP, there exists a provable HOL problem
  $\Gamma' \vdash? p'$ and substitution $(\pi(\Gamma'), \Gamma, \sigma)$ such that
  $p \cong \overline{\sigma}(\pi(p'))$. By the definition of HOL provability, there exists
  a term $t'$ such that $\pi(\Gamma') \vdash t' : \pi(p')$. By theorem \ref{ceptj},
  $\Gamma \vdash \overline{\sigma}(t') : \overline{\sigma}(\pi(p'))$, thus $\Gamma \vdash? p$
  is provable.
\end{proof}

%TODO: Define HOL

\begin{theorem} An $\text{HOL}^*$ problem is provable iff it is HOL provable after forgetting
  universe levels, assuming the existence of lifting functions in $\lambda C$.
\end{theorem}
\begin{proof}
  % TODO: Put this after the definition of provability
  %       Maybe a direct induction would be more elegant?
  If a $\lambda_\to^*$ problem is provable, obviously it is $\lambda_\to$ provable
  after forgetting the universe levels. If a $\lambda_\to^*$ problem is $\lambda_\to$ provable
  after forgetting the universe levels, note that the lifting of a $\lambda_\to^*$ problem is sort of
  an instance of the problem after forgetting universe levels, hence provable. Moreover,
  a $\lambda_\to^*$ problem is provable iff its lifting is provable.  
\end{proof}

We define logical symbols in $\lambda C$ as follows:
$$\bot := \forall p : \mathsf{U}_0. p \ \ \ (\neg) := \lambda p : \mathsf{U}_0. p \to \bot$$
$$(\land) := \lambda p \ q : \mathsf{U}_0. \forall r : \mathsf{U}_0. (p \to q \to r) \to r$$
$$(\lor) := \lambda p \ q : \mathsf{U}_0. \forall r : \mathsf{U}_0. (p \to r) \to (q \to r) \to r$$
$$(\leftrightarrow) := \lambda p \ q. (p \to q) \land (q \to p)$$
$$(=_\ell) := \lambda \alpha : \mathsf{U}_\ell. \lambda x \ y : \alpha. \forall p : \alpha \to \mathsf{U}_0. (p \ x \leftrightarrow p \ y)$$
$$(\exists_\ell) := \lambda \alpha : \mathsf{U}_\ell. \lambda p : \alpha \to \mathsf{U}_0. \forall q : \mathsf{U}_0. ((\forall x : \alpha. p \ x \to q) \to q)$$

The symbols $\neg', \land', \lor', \leftrightarrow'$ are defined in HOL in the
same way, except that the $\mathsf{U}_0$s are replaced with $\mathsf{Bool}$ and the $\to$s are
replaced with $\to'$. Equality and existential quantifier in HOL are defined as follows:
$$(=_s') := \lambda x \ y : s. \forall' p : \alpha \to \mathsf{Bool}. (p \ x \leftrightarrow' p \ y)$$
$$(\exists_s') := \lambda p : \alpha \to \mathsf{Bool}. \forall' q : \mathsf{Bool}. ((\forall' x : \alpha. p \ x \to' q) \to' q)$$

We also assume that excluded middle, i.e. $\mathsf{em} : \forall p : \mathsf{U}_0, p \lor \neg p$,
is implicitly contained in the hypotheses of all $\lambda C$ problems. Similarly, $\mathsf{em}' : \forall p : \mathsf{Bool}. p \lor \neg p$
is assumed to be implicitly contained in the hypotheses of all HOL problems.

\begin{example} Consider the $\lambda C$ problem $\Gamma \vdash? p$ where
\begin{align*}
  \Gamma := \ & \mathbb{N} : \mathsf{U}_1, \mathsf{Fin} : \mathbb{N} \to \mathsf{U}_1,
  \mathsf{add} : \forall n : \mathbb{N}. (\mathsf{Fin} \ n \to \mathsf{Fin} \ n \to \mathsf{Fin} \ n), n : \mathbb{N} \\
  p := \ & (\forall (u \ v : \mathsf{Fin} \ n). \mathsf{add} \ n \ u \ v =_1 \mathsf{add} \ n \ v \ u) \to \\
  & \ \ \ \forall (u \ v \ w : \mathsf{Fin} \ n). \mathsf{add} \ n \ (\mathsf{add} \ n \ x \ y) \ z =_1 \mathsf{add} \ n \ z \ (\mathsf{add} \ n \ y \ x)
\end{align*}
Given
\begin{align*}
  \Gamma' := \ & \alpha : \mathsf{U}_1, f : \alpha \to \alpha \to \alpha \\
  p' := \ & (\forall' (u \ v : \alpha). f \ u \ v =_\alpha' f \ v \ u) \to' \\
  & \ \ \ \forall' (u \ v \ w : \alpha). f \ (f \ u \ v) \ w =_\alpha' f \ w \ (f \ v \ u)
\end{align*}
The higher-order problem $\Gamma' \vdash? p'$ is provable. Moreover, given
$$\sigma(\alpha) := \mathsf{Fin} \ n, \sigma(f) := \mathsf{add} \ n$$
The triple $(\pi(\Gamma'), \Gamma, \sigma)$ forms a substitution, and $p \cong \overline{\sigma}(\pi(p'))$.
Therefore, $\Gamma \vdash? p$ is EHOP.
\end{example}

Note that moving implications in the goal into hypotheses (and vice versa) may
change the EHOP status of a problem. For example,
$$\alpha : \mathsf{U}_1, x : \alpha, p : \alpha \to \mathsf{U}_0 \vdash? p \ x \to p \ x$$
is EHOP. However, if we introduce $p \ x$ into the hypotheses, the problem is no longer EHOP:
\begin{equation}\label{hypnehop}
  \alpha : \mathsf{U}_1, x : \alpha, p : \alpha \to \mathsf{U}_0, h : p \ x \vdash? p \ x
\end{equation}

\begin{theorem}
  The $\lambda C$ problem \eqref{hypnehop} is provable but not EHOP.
\end{theorem}
\begin{proof}
  Note that $h : p \ x$ under the hypotheses of \eqref{hypnehop}, thus \eqref{hypnehop} is provable.
  To show that \eqref{hypnehop} is not EHOP, we use proof by contradiction. Suppose there
  is an HOL problem $\Gamma' \vdash p'$ and a substitution $(\Gamma', \Gamma, \sigma)$ such
  that $p \cong \overline{\sigma}(\pi(p'))$. Then, the $\beta\eta$ normal form of $p'$ must be of the form
  $f \ t_1 \ \dots \ t_k$ where $f$ is a variable. Note that $\Gamma'$, as a context of $\lambda_\to^*$,
  consists solely of HOL (type or term) variable declarations.
  % TODO: Use model theory
\end{proof}

\subsection{$\lambda_\to^*$ abstraction algorithm}

In this subsection, we will present the $\lambda_\to^*$ abstraction algorithm of Lean-auto. When given a
$\lambda C$ problem $\Gamma \vdash? p$, the algorithm attempts to find a $\lambda_\to^*$
problem $\Gamma' \vdash? p'$ and a substitution $(\pi(\Gamma'), \Gamma, \sigma)$ such that
$p \cong \overline{\sigma}(\pi(p'))$. If the algorithm succeeds, then by definition, $\Gamma \vdash? p$
is EHOP, which intuitively means that $\Gamma' \vdash p'$ is provable in HOL, and that the
proof of $\Gamma' \vdash? p'$ can be translated into a proof of $\Gamma \vdash? p$ via
the mapping $\sigma$.

We start by defining dependent arguments of terms.

\begin{definition} Suppose $\Gamma \vdash s : \mathsf{U}_l$ in $\lambda C$.
  If $s = (\forall (x : s_1). s_2)$ and $x$ occurs in $s_2$,
  then $s$ is said to be a $\Gamma$-leading argument dependent type,
  denoted as $\mathsf{LADT}(\Gamma; s)$. Suppose $\Gamma \vdash t : s$ in $\lambda C$, where $s$
  is in $\beta$ normal form. If $\mathsf{LADT}(\Gamma; s)$, then $t$ is said to be
  $\Gamma$-leading argument dependent ($\Gamma$-lad), denoted as $\mathsf{LAD}(\Gamma; t)$.
\end{definition}

\begin{definition} Suppose the term $a_0 \ a_1 \ \dots \ a_k$ is type correct under
  context $\Gamma$ in $\lambda C$. Then for $1 \leq i \leq k$, $a_0$ is said to have dependent $i$-th argument
  with respect to $\Gamma$ and argument list $(a_1, \dots, a_k)$, or $i$-dep w.r.t
  $\Gamma$ and $(a_1, \dots, a_k)$, iff $\mathsf{LAD}(\Gamma; a_0 \ a_1 \ \dots \ a_{i - 1})$.
  For convenience, we use the predicate
  $$\mathsf{Dep}(\Gamma; a_0, (a_1, \dots, a_k), i) \ \ \ (k \geq 0, 1 \leq i \leq k)$$
  to denote that $a_0$ is $i$-dep w.r.t $\Gamma$ and $(a_1, \dots, a_k)$. Furthermore, we define
  $$\mathsf{LFun}(\Gamma; a_0, (a_1, \dots, a_k)) := \lambda (x_{i_1} : s_{i_1}) \dots (x_{i_m} : s_{i_m}). a_0 \ w_1 \ \dots \ w_m$$
  $$\mathsf{DArgs}(\Gamma; a_0, (a_1, \dots, a_k)) := (b_{i_1}, \dots, b_{i_m})$$
  $$\mathsf{LArgs}(\Gamma; a_0, (a_1, \dots, a_k)) := (a_{j_1}, \dots, a_{j_{k - m}})$$
  where $i_1 < i_2 < \dots < i_m$ are all the arguments that are dependent, $j_1 < j_2 < \dots < j_{k - m}$
  are all the arguments that are non-dependent, $\Gamma \vdash a_i : s_i$, and
  $$w_i := \left\{\begin{aligned}
    a_i, & & \mathsf{Dep}(\Gamma; a_0, (a_1, \dots, a_k), i) \\
    x_i, & & \text{otherwise}
  \end{aligned}\right.$$
\end{definition}

\begin{example} Let
  \begin{align*}
    \Gamma := & \ \mathsf{compose} : \forall (\beta \ \gamma: \mathsf{U}_1).
      (\beta \to \gamma) \to \forall (\alpha : \mathsf{U}_1). (\alpha \to \beta) \to (\alpha \to \gamma), \\
      & \ A : \mathsf{U}_1, B : \mathsf{U}_1, C : \mathsf{U}_1, f : B \to C, g : A \to B, x : A
  \end{align*}
  Then
  $$\mathsf{compose}, \mathsf{compose} \ B, \mathsf{compose} \ B \ C \ f$$
  are $\Gamma$-lad, while
  $$\mathsf{compose} \ B \ C, \mathsf{compose} \ B \ C \ f \ A, \mathsf{compose} \ B \ C \ f \ A \ g$$
  are not. Therefore, the dependent arguments of $\mathsf{compose}$ w.r.t $(A, B, C, f, g, x)$
  are $1, 2$ and $4$, and we have
  $$\mathsf{LFun}(\Gamma; \mathsf{compose}, (A, B, C, f, g, x)) = \lambda (f : B \to C). \mathsf{compose} \ A \ B \ f \ C$$
  $$\mathsf{LArgs}(\Gamma; \mathsf{compose}, (A, B, C, f, g, x)) = (f, g, x)$$
\end{example}

\begin{example} Let
  \begin{align*}
    \Gamma := \mathsf{func} : \forall (\alpha : \mathsf{U}_1 \to \mathsf{U}_1) \ (\beta : \mathsf{U}_1). \alpha \ \beta,
      A : \mathsf{U}_1, B : \mathsf{U}_1 
  \end{align*}
  Then $\mathsf{func}$ is $\Gamma$-lad, while
  $$\mathsf{func} \ (\lambda \beta. A) : \forall (\beta : \mathsf{U}_1). A \ \ \ \ \ \
  \mathsf{func} \ (\lambda \beta. A) \ B : A$$
  are not. Therefore, the dependent argument of $\mathsf{func}$ w.r.t $(\lambda \beta. A, B)$ is $1$, and
  we have
  $$\mathsf{LFun}(\Gamma; \mathsf{func}, (\lambda \beta. A, B)) = \mathsf{func} \ (\lambda \beta . A) \ \ \ \ \ \
  \mathsf{LArgs}(\Gamma; \mathsf{func}, (\lambda \beta. A, B)) = B$$
\end{example}

Now, we define the concept of quasi-monomorphic terms, the set of $\lambda C$ terms
  that Lean-auto can successfully abstract to $\lambda_\to^*$. Intuitively, quasi-monomorphic
  terms are $\lambda C$ terms that are structurally similar to HOL terms.

\begin{definition} We define the predicate $\mathsf{QMono}(\Gamma; V, t)$ inductively,
  where $\Gamma$ is a $\lambda C$ context, $V$ is a set of variables, and $t$ is a $\lambda C$ term
  \begin{enumerate}
    \item For variable $x \in V$ and terms $t_1, \dots, t_n$,
      \begin{align*}
        \mathsf{QMono}(\Gamma; V, x \ t_1 \dots \ t_n) := \ &
        \mathsf{DArgs}(\Gamma; x, (t_1 \ \dots \ t_n)) = \emptyset \land \\
        & \forall i \in \{1, \dots, n\}. \mathsf{QMono}(\Gamma; V, t_i)
      \end{align*}
    \item For variable $x \notin V$ and terms $t_1, \dots, t_n$,
      \begin{align*}
        \mathsf{QMono}(\Gamma; V, x \ t_1 \dots \ t_n) := \ & (\forall t \in \mathsf{DArgs}(\Gamma; x, (t_1, \dots, t_n)). FV(t) \cap V = \emptyset) \land \\
        & (\forall t \in \mathsf{LArgs}(\Gamma; x, (t_1, \dots, t_n)). \mathsf{QMono}(\Gamma; V, t))
      \end{align*}
    \item For variable $x$ and terms $s, t$
      \begin{align*}
        \mathsf{QMono}(\Gamma; V, \lambda (x : s). t) := \
        & FV(s) \cap V = \emptyset \land (\Gamma \not\vdash s : \mathsf{U}_0) \\
        & \land \mathsf{QMono}(\Gamma, x : s; V \cup \{x\}, t)
      \end{align*}
    \item For variable $x$ and terms $s, t$ such that $x \in FV(t)$,
      \begin{align*}
        \mathsf{QMono}(\Gamma; V, \forall (x : s). t) := \
        & \neg FV(s) \cap V = \emptyset \land (\Gamma \not \vdash s : \mathsf{U}_0) \land  (\Gamma \vdash t : \mathsf{U}_0) \land \\
        & \mathsf{QMono}(\Gamma, x : s; V \cup \{x\}, t)
      \end{align*}
    \item For terms $s, t$,
      \begin{align*}
        \mathsf{QMono}(\Gamma; V, s \to t) := \ & (\Gamma \vdash s : \mathsf{U}_0) \land (\Gamma \vdash t : \mathsf{U}_0) \land \\
        & \mathsf{QMono}(\Gamma; V, s) \land \mathsf{QMono}(\Gamma; V, t)
      \end{align*}
  \end{enumerate}
\end{definition}

According to the definition of $\mathsf{QMono}$, terms coming from canonical embedding of $\lambda_\to^*$
terms are automatically quasi-monomorphic, e.g.
$$\mathsf{QMono}(\alpha : \mathsf{U}_1, p : (\alpha \to \alpha) \to \mathsf{U}_0; \emptyset, \forall (p : \alpha \to \alpha). f \ p)$$
Proofs are not allowed to be quantified by $\lambda$ or dependent $\forall$ binders:
$$\neg \mathsf{QMono}(p : \mathsf{U}_0, q : p \to \mathsf{U}_0; \emptyset, \forall (x : p). q \ x)$$
Occurrence of a dependently typed free variable does not break the quasi-monomorphic property iff
its dependent arguments do not contain bound variables (assuming $V = \emptyset$):
\begin{align*}
  \mathsf{QMono}(
  & \mathbb{N} : \mathsf{U}_1, \mathsf{Fin} : \mathbb{N} \to \mathsf{U}_1,
    \mathsf{add} : \forall (n : \mathbb{N}). \mathsf{Fin} \ n \to \mathsf{Fin} \ n \to \mathsf{Fin} \ n, k : \mathbb{N}; \\
  & \emptyset, \forall (x \ y : \mathsf{Fin} \ k). \mathsf{add} \ k \ x \ y = \mathsf{add} \ k \ y \ x)
\end{align*}
Occurrence of a dependently typed bound variable does not break the quasi-monomorphic property iff
its dependent arguments are not instantiated:
$$\mathsf{QMono}(\emptyset; \emptyset, \lambda (f : (\forall (\alpha : \mathsf{U}_0). \alpha) \to (\forall (\alpha : \mathsf{U}_0). \alpha)) \
  (x : \forall (\alpha : \mathsf{U}_0). \alpha). f \ x)$$
  
Except for within type declarations of bound variables, bodies of $\forall$ binders must be propositions:
$$\neg \mathsf{QMono}(\alpha : \mathsf{U}_1, \beta : \alpha \to \mathsf{U}_1; \emptyset, \forall (x : \alpha). \beta \ x)$$

\begin{algorithm}\label{lamabst}
  \DontPrintSemicolon
  \SetNoFillComment
  \SetKwFunction{lamAbstraction}{\textsf{lamAbst}}
  \SetKwFunction{gvn}{\textsf{getLVarName}}
  \caption{$\lambda_\to^*$ abstraction algorithm of Lean-auto}
  \Fn{\gvn{t}} {
    \Input{$\lambda C$ term $t$}
    \Output{$\lambda_\to^*$ variable name corresponding to $t$}
    \uIf{$H.\mathsf{contains}(t)$}{
      \Return $H.\mathsf{find}(t)$
    }
    $\vnewname := \mathsf{freshVarName}()$ \;
    $H.\mathsf{add}(t, \vnewname)$ \;
    \Return $\vnewname$ 
  }
  \;
  \Fn{\lamAbstraction{$\Gamma; V, t$}}{
    \Input{$\lambda C$ context $\Gamma$, variable set $V$,
      and $\lambda C$ term $t$ satisfying $\mathsf{QMono}(\Gamma; V, t)$}
    \Output{a $\lambda_\to^*$ term}
    \Switch(\textbf{with}){t}{
      \Case(\tcc*[h]{Function application}){$a \ b$}{
        $f := \mathsf{getAppFn}(t)$ \;
        $\vargs := \mathsf{getAppArgs}(t)$ \;
        \uIf{$f \in V$}{
          \For{$a : \vargs$}{$a := \mathsf{lamAbst}(\Gamma; V, a)$}
          \Return $\mathsf{mkAppN}(f, \vargs)$
        }
        $\vlf := \mathsf{LFun}(\Gamma; f, \vargs)$ \;
        $\vlargs := \mathsf{LArgs}(\Gamma; f, \vargs)$ \;
        $\vlvar := \mathsf{getLVarName}(\vlf)$ \;
        \Return $\mathsf{mkAppN}(\vlvar, \vlargs)$
      }
      \Case{$\forall (v : a). b$}{
        $\vatype := \mathsf{inferType}(\Gamma; a)$ \;
        $\vbabst := \mathsf{lamAbst}(\Gamma, v : a; V \cup \{v\}, b)$ \;
        \uIf{$\vatype = \mathsf{U}_0$}{
          $\vaabst := \mathsf{lamAbst}(\Gamma; V, a)$ \;
          \Return $\vaabst \to \vbabst$
        }
        \Return $\forall (v : a). \vbabst$
      }
      \Case{$\lambda (v : a). b$}{
        $\vbabst := \mathsf{lamAbst}(\Gamma, v : a; V \cup \{v\}, b)$ \;
        \Return $\lambda (v : a). \vbabst$
      }
      \Other{\Return $\mathsf{getLVarName}(t)$}
    }
  }
\end{algorithm}

Now, we describe the $\lambda_\to^*$ abstraction procedure $\mathsf{lamAbst}$ of Lean-auto. The algorithm
is shown in \textbf{Algorithm \ref{lamabst}}. A global hash map $H$ is used to record the $\lambda_\to^*$
free variables associated with abstracted $\lambda C$ terms. A few auxiliary functions are used in the algorithm:
\begin{enumerate}
  \item For a term $t$, if $t$ is in $H$, then the $\mathsf{getLVarName}(t)$ returns
    the $\lambda_\to^*$ free variable corresponding to $t$, otherwise it creates a new $\lambda_\to^*$ free variable for $t$.
  \item For a term $t = w \ t_1 \ \dots \ t_n$ where $w$ is not an application,
    $\mathsf{getAppFn}(t) = w, \mathsf{getAppArgs}(t) = (t_1, \dots, t_n)$.
  \item For terms $w, t_1, \dots, t_n$, $\mathsf{mkAppN}(w, (t_1, \dots, t_n)) = w \ t_1 \ \dots \ t_n$.
  \item For a context $\Gamma$ and a term $t$, $\mathsf{inferType}(\Gamma, t)$ computes the
    $\beta$-normal form of the type of $t$ under $\Gamma$
\end{enumerate}
Note that $\mathsf{lamAbst}$ only returns the higher-order problem (as a $\lambda_\to^*$ term). The
substitution from $\lambda_\to^*$ to $\lambda C$ needs to be obtained by computing the inverse of $H$ after
the execution of the algorithm. Also, note that the implementation of this algorithm in Lean-auto checks
whether $t$ is quasi-monomorphic and fails if it's not. For simplicity, these checks have been omitted in $\mathsf{lamAbst}$.

% TODO: Use a better algorithm to deal with cases like identifying that
% the dependent arguments of $\mathsf{func}$ w.r.t $(B, \lambda \beta. A)$ is $2$ instead of $1,2$ under context
% $$\Gamma := \mathsf{func} : \forall (\alpha : \mathsf{U}_1) \ (\beta : \mathsf{U}_1 \to \mathsf{U}_1). \beta \ \alpha,
%   A : \mathsf{U}_1, B : \mathsf{U}_1$$
% Note that the algorithm will be relatively straightforward