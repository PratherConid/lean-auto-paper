\section{Preliminaries}

\subsection{Dependent Type Theory}\label{subdtt}

  Dependent type theory, or $\lambda C$ in the $\lambda$-cube,
  or \textit{calculus of constructions} (CoC) \cite{LambdaWithType},
  is a highly expressive type system and logical system. It is the logical
  foundation of Coq, Lean4 and Agda. To align with the logical system of
  Lean4, we will use the variant of $\lambda C$ which contains a countable
  number of non-cumulative universe levels. The syntax of terms of $\lambda C$ is defined
  inductively as follows:
  $$\mathcal{T}_C ::= V \ | \ \mathsf{U}_\ell \ | \ \mathcal{T}_C \ \mathcal{T}_C \ |
    \ \lambda (V : \mathcal{T}_C). \mathcal{T}_C \ | \ \forall (V : \mathcal{T}_C). \mathcal{T}_C$$
  where $V$ is the set of variables, $\mathsf{U}_\ell (\ell \in \mathbb{N})$ are
  the sorts (i.e. types of type) and $\ell$ is called the universe level
  of $\mathsf{U}_\ell$, $\mathcal{T}_C \ \mathcal{T}_C$ is function application,
  $\lambda (V : \mathcal{T}_C). \mathcal{T}_C$ is $\lambda$ abstraction, and
  $\forall (V : \mathcal{T}_C). \mathcal{T}_C$ is product type.
  We use $\forall$ instead of $\mathrm{\Pi}$ to align with the syntax of Lean, Coq and Agda.
  Syntactical equality of terms will be denoted as $=$, and the $\beta\eta$-equivalence of terms will be
  denoted as $\cong$.
  
  We adopt the following commonly used notational conventions:
  function application binds stronger than $\lambda$ and $\forall$, and is left associative;
  consecutive $\lambda$s and $\forall$s can be merged, and $\lambda$s and $\forall$s with the same
  binder type can be further merged into the same parenthesis; when the product type is non-dependent,
  $\to$ can be used instead of $\forall$. Importantly, $\to$ binds stronger than $\forall$, i.e.,
  $\forall (x : \alpha). \beta \to \gamma$ is interpreted as $\forall (x : \alpha). (\beta \to \gamma)$
  instead of $(\forall (x : \alpha). \beta) \to \gamma$, the latter being the convention commonly used
  when presenting FOL and HOL.

  Type judgements will be written as $\Gamma \vdash t : \alpha$, which stands for ``$\lambda C$ term $t$
  has type $\alpha$ under context $\Gamma$''. Derivation rules for type judgements of
  $\lambda C$ will be given in sect. \ref{sectpts}. If $\Gamma \vdash t : \alpha$, then $t$ is
  called a \textit{well-formed term}, and $\alpha$ is called a (well-formed)
  \textit{type}\footnote{In $\lambda C$, all well-formed types are also well-formed terms}.
  Under context $\Gamma$, a type $\alpha$ is called \textit{inhabited} iff there exists $t$ such
  that $\Gamma \vdash t : \alpha$, in which case $t$ is called an \textit{inhabitant} of $\alpha$.
  Propositions are types of type $\mathsf{U}_0$. A \textit{proof} of a proposition
  $p : \mathsf{U}_0$ is an inhabitant of $p$. A proposition $p : \mathsf{U}_0$ is \textit{provable}
  iff it is inhabited.

  For a function $f : \forall (x_1 : \alpha_1) \ \dots \ (x_n : \alpha_n). \beta$ (here $\beta$ may begin with $\forall$),
  the $n$-th argument of $f$ is called a \textit{static dependent argument} iff $x_n$ occurs in $\beta$.
  In many cases, dependent arguments are also type arguments, for example the first and second argument
  of $\mathsf{List.map} : \forall (\alpha \ \beta : \mathsf{U}_1). (\alpha \to \beta) \to \mathsf{List} \ \alpha \to \mathsf{List} \ \beta$.
  We also use the terminology \textit{dependent argument}

  We use $\lambda C$ notation for all logical systems that can be embedded in $\lambda C$.
  When presenting Lean4 examples, we will follow extra notational conventions
  of Lean4, which will be explained in sect. \ref{sectlean}.

\subsection{Logical Systems of ITPs and ATPs}\label{sublogsys}

  In this section, we give overviews of the various logical systems
  that are relevant to our paper. In the following list, the logical systems
  are ordered from the least expressive to the most expressive. Note that, except
  for $\lambda C$ and more expressive systems, all other logical systems have
  two components: term calculus (which specifies the construction and computation
  rules of terms), and logical axioms/rules.
  \begin{enumerate}
    \item Untyped FOL, or predicate logic
    \item Many-sorted FOL
    \item Many-sorted HOL (monomorphic HOL, or just HOL), where functions are allowed
      to take function as arguments, and quantifiers can quantify over functions.
    \item Many-sorted HOL with a countable number of universe levels, denoted as $\text{HOL}^*$. This is an
      intermediate logical system used in Lean-auto's monomorphization. Its term calculus $\lambda_\to^*$
      will be discussed in sect. \ref{sectpts}.
    \item HOL with rank-1 polymorphism, or polymorphic HOL, whose term calculus is identical
      to $\lambda 2$ in the $\lambda$-cube \cite{LambdaWithType}. In polymorphic HOL, function are
      allowed to take type arguments, and quantifiers can quantify over types. However, type
      constructors, or types dependent on types, are not allowed.
    \item Isabelle: Based on polymorphic HOL. Supports (co)inductive datatypes and recursive functions.
    \item Dependent type theory, or $\lambda C$. Compared to polymorphic HOL, types can depend on terms and types in $\lambda C$.
    \item Coq, Lean4 and Agda: Based on $\lambda C$. Extensions to $\lambda C$ that are
      present in (at least one of) these ITPs include (co)inductive types, universe levels,
      universe polymorphism, typeclasses and many others.
  \end{enumerate}
  
  \noindent All previously mentioned hammers translate between these logical systems. Isabelle
  Sledgehammer translates between Isabelle and
  HOL/FOL\footnote{The exact logical system depends on the mode being used}.
  CoqHammer translates between Coq and untyped FOL. Lean-auto translates
  between Lean4 and monomorphic HOL. As mentioned before, Lean-auto's
  preprocessing translates Lean4 into $\lambda C$, and monomorphization
  translates $\lambda C$ into monomorphic HOL.

\subsection{Lean and Mathlib}\label{sectlean}

  Lean is an interactive theorem prover based on dependent type theory. Lean-auto
  is implemented in Lean4, the latest version of Lean. At present, the
  most prominent project in Lean is Mathlib \cite{MathlibPaper},
  which was later renamed to Mathlib4\footnote{Github link: https://github.com/leanprover-community/mathlib4}
  when it was moved to Lean4. Notably, Mathlib is the foundation of the
  Liquid Tensor Experiment \cite{LiquidTensor}, which successfully
  formalized cutting-edge results in mathematics. 

  We will follow Lean4 conventions when presenting Lean4 examples. Sorts $\mathsf{U}_{\ell + 1}$
  are printed as \texttt{Type $\ell$} (\texttt{Type $0$} can be abbreviated as \texttt{Type}), and $\mathsf{U}_0$ is printed as \texttt{Prop}.
  Functions and constants can have universe level parameters, but for simplicity,
  they are not shown in many of our Lean4 examples. 
  Functions are allowed to have implicit arguments, which are represented by
  $\{x : \alpha\}$ instead of $(x : \alpha)$ in the type of the function.
  Prepending \textrm{@} to the name of a function causes implicit arguments
  to become explicit. For example, given the polymorphic list map function
  with the first and second argument being implicit:

  \centerline{\texttt{List.map : $\forall$ \{$\alpha \ \beta$ : Type\}, ($\alpha$ → $\beta$) → List $\alpha$ → List $\beta$}}
  
  \noindent the expression \texttt{@List.map $\alpha$ $\beta$ f} is the same as \texttt{List.map f}, where \texttt{f : $\alpha$ → $\beta$}.

  Typeclasses are extensively used by Lean4's builtin library and Mathlib4 to
  overload arithmetic operators and represent mathematical structures. For example,
  consider the \texttt{HAdd} typeclass and the \texttt{HAdd.hAdd} function
  used to represent the addition operator in Lean4
  
  \centerline{\texttt{HAdd : $\forall$ ($\alpha \ \beta \ \gamma$ : Type), Type}}
  \centerline{\texttt{HAdd.hAdd : $\forall$ \{$\alpha \ \beta \ \gamma$ : Type\} [self : HAdd $\alpha \ \beta \ \gamma$], $\alpha$ → $\beta$ → $\gamma$}}

  \noindent An inhabitant of \texttt{HAdd $\alpha \ \beta \ \gamma$}, called a
  typeclass instance, is a wrapper of a ``heterogeneous'' addition operator (with $\alpha$ and $\beta$ as its input types and
  $\beta$ as its output type). The square bracket in the type of \texttt{HAdd.hAdd}
  indicates that the enclosed argument is an instance argument, which is a special type
  of implicit argument intended to be filled by Lean4's typeclass inference algorithm.
  Given the syntax \texttt{x + y} where \texttt{x : $\alpha$} and \texttt{y : $\beta$},
  the typeclass inference algorithm will attempt to find a type $\gamma$ and a previously
  defined instance \texttt{inst : HAdd $\alpha \ \beta \ \gamma$}, and elaborate the
  syntax \texttt{x + y} into the expression \texttt{@HAdd.hAdd $\alpha \ \beta \ \gamma$ inst}.
  In \texttt{@HAdd.hAdd $\alpha \ \beta \ \gamma$ inst}, the \texttt{HAdd.hAdd} function
  unwraps \texttt{inst} and returns the addition operator. This provides a mechanism
  for overloading the addition operator. The same mechanism is used to represent mathematical
  structures. For example, a group is just a wrapper for its identity element, multiplication
  operator, inverse operator, and a proof that these operators follow the group axioms.

  Other important features of Lean4 include inductive types, recursive functions
  and definitional equality. These features and how Lean-auto handles them will be discussed
  in sect. \ref{sectprep}.

\subsection{Pure Type Systems}\label{sectpts}

  Pure type system (PTS) \cite{LambdaWithType} is a mechanism which enables concise specification
  for a certain class of type systems. We use PTS to formally specify the underlying type systems
  of the logical systems used in Lean-auto's translation.

  The specification of a PTS consists of a triple $(\mathcal{S}, \mathcal{A}, \mathcal{R})$,
  where $\mathcal{S}$ is the set of \textit{sorts}, $\mathcal{A} \subseteq \mathcal{S} \times \mathcal{S}$ is
  the set of \textit{axioms}, and $\mathcal{R} \subseteq \mathcal{S} \times \mathcal{S} \times \mathcal{S}$
  is the set of \textit{rules}. An axiom $(s_1, s_2) \in \mathcal{A}$ is intended to represent
  the typing relation $s_1 : s_2$. The term syntax of a PTS is defined as
  $$\mathcal{T} ::= V \ | \ \mathcal{S} \ | \ \mathcal{T} \ \mathcal{T} \ |
    \ \lambda (V : \mathcal{T}). \mathcal{T} \ | \ \forall (V : \mathcal{T}). \mathcal{T}$$
  \noindent The derivation rules of PTS are given in Appendix \ref{apppts}.

  Three type systems, $\lambda C$, $\lambda_\to$ and $\lambda_\to^*$, will be formulated
  using PTS. As mentioned in sect. \ref{sublogsys}, $\lambda_\to$
  is the term calculus of monomorphic HOL, and $\lambda_\to^*$ is the term
  calculus of $\text{HOL}^*$. Note that $\mathsf{U}_0$ is not present in $\lambda_\to$ and $\lambda_\to^*$
  because it is a special sort for propositions in $\lambda C$.
  Propositions in $\text{HOL}$ and $\text{HOL}^*$ will be represented by
  a special type $\mathsf{Bool} : \mathsf{U}_1$.
  
  $\lambda_\to^*$ and $\lambda_\to$ are similar, except that $\lambda_\to^*$ allows a
  countable number of universe levels $\ell \in \mathbb{N}^*$. For example,
  for the type $(\alpha \to \beta) \to \gamma$, if in $\lambda_\to$,
  then $\alpha \ \beta \ \gamma$ must be of type $\mathsf{U}_1$; if in
  $\lambda_\to^*$, then it's possible that $\alpha : \mathsf{U}_{\ell_1},
  \beta : \mathsf{U}_{\ell_2}, \gamma : \mathsf{U}_{\ell_3}$ where $\ell_1, \ell_2, \ell_3$
  may be different. A technicality related to PTS requires the presence of
  the sorts $\mathsf{U}_\ell'$ in $\lambda_\to^*$, with axioms $\mathsf{U}_\ell : \mathsf{U}_\ell'$.

  The specifications of $\lambda C, \lambda_\to$ and $\lambda_\to^*$ using PTS are given in
  Appendix \ref{applll}. The set of $\lambda_C, \lambda_\to$ and $\lambda_\to^*$ terms will be
  denoted as $\mathcal{T}_C, \mathcal{T}_\to$ and $\mathcal{T}_\to^*$, respectively.