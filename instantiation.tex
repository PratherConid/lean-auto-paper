\section{Quantifier Instantiation}
Given a context $\Gamma$ and a list of hypotheses $h_1 : t_1, \dots, h_n : t_n$, the quantifier
instantiation procedure of Lean-auto attempts to instantiate quantifiers in
$t_1, \dots, t_n$ to obtain terms suitable for $\lambda_\to^*$ abstraction.
As mentioned in section \ref{motex}, the quantifier instantiation procedure
is based on a saturation loop which matches instances of polymorphic functions
with subterms of hypothesis instances.

\noindent An instance of a polymorphic function is called \textit{monomorphic} iff all
of its dependent arguments are instantiated with terms that do not contain bound
variables. Formally, the set of monomorphic instances of polymorphic functions in a
$\lambda C$ term is defined as follows:

\begin{definition}
  Let $\Gamma$ be a $\lambda C$ context and $V$ be a set of variables, then
  \begin{enumerate}
    \item For variable $x$ and terms $t_1, \dots, t_n$,
      $$\mathsf{monoInst}(\Gamma; V, x \ t_1 \ \dots \ t_n) := \left\{
        \begin{aligned}
          S \cup \{l\}, & & FV(l) \cap V = \emptyset \\
          S, & & \text{otherwise}
        \end{aligned}
      \right.$$
      where
      $$l := \mathsf{LFun}(\Gamma; x, (t_1 \ \dots \ t_n)) \ \ \ \ \ \ S := \bigcup_{t \in \mathsf{LArgs}(\Gamma; x, (t_1, \dots, t_n))} \mathsf{monoInst}(\Gamma; V, t)$$
    \item For variable $x$ and terms $a, b$,
      \begin{align*}
        \mathsf{monoInst}(\Gamma; V, \forall (x : a). b) = \mathsf{monoInst}(\Gamma; V, \lambda (x : a). b) 
        \\ := \mathsf{monoInst}(\Gamma; V, a) \cup \mathsf{monoInst}(\Gamma, x : a; V \cup \{x\}, b)
      \end{align*}
    \item Otherwise, $\mathsf{monoInst}(\Gamma; V, t) := \emptyset$
  \end{enumerate}
\end{definition}

\noindent The matching procedure in the saturation loop is handled by $\mathsf{matchInst}$ and
$\mathsf{match}$. Given context $\Gamma$, variable set $M$ and terms $m, h$
\begin{enumerate}
  \item $\mathsf{match}(\Gamma; M, m, h)$ returns all $M$-unifiers between term $m$ and the $\mathsf{LFun}$ of subterms of $h$.
    The pseudocode for $\mathsf{match}$ is given in \textbf{Algorithm \ref{matching}}. An auxiliary function
    $\mathsf{unify}$ is used in the pseudocode. Given $\lambda C$ context $\Gamma$, variable set $M$
    and two $\lambda C$ terms $t_1, t_2$, $\mathsf{union}(\Gamma; M, t_1, t_2)$ returns a complete set of
    $M$-unifiers of $t_1$ and $t_2$ under $\Gamma$. In Lean, the function $\mathsf{Meta.isDefEq}$ is the closest
    to the $\mathsf{union}$ here, but $\mathsf{Meta.isDefEq}$ always returns at most one unifier.
  \item $\mathsf{matchInst}(\Gamma; m, h)$ introduces all leading non-prop $\forall$ quantifiers into the context
    (as free variables), collects all the newly introduced free variables into a variable set $M$, then returns
    $\mathsf{match}(\Gamma'; M, m, h')$, where $\Gamma', h'$ are $\Gamma, h$ after introduction of free variables.
    In Lean, this is equivalent to calling $\mathsf{match}$ after instantiating all the leading non-prop
    $\forall$ quantifiers of $h$ with metavariables.
\end{enumerate}

\textbf{TODO:} Non-subsumption equivalence; Saturation loop

\begin{algorithm}\label{matching}
  \DontPrintSemicolon
  \SetNoFillComment
  \SetKwFunction{matchFun}{\textsf{match}}
  \caption{Matching algorithm for quantifier instantiation}
  \Fn{\matchFun{$\Gamma; M, m, h$}}{
    \Input{$\lambda C$ context $\Gamma$, variable set $M$, and $\lambda C$ terms $m, h$}
    \Output{A set of unifiers}
    \Switch(\textbf{with}){h}{
      \Case(\tcc*[h]{Function application}){$a \ b$}{
        $matches := \emptyset$ \;
        $f := \mathsf{getAppFn}(t)$ \;
        $args := \mathsf{getAppArgs}(t)$ \;
        \For{a : args}{$matches := \mathsf{union}(matches, \mathsf{match}(\Gamma; M, m, a))$}
        $lf := \mathsf{LFun}(\Gamma; f, arg)$ \;
        $matches := \mathsf{union}(matches, \mathsf{unify}(\Gamma; M, m, lf))$
      }
      \Case{$\forall (v : a). b$}{
        \Return $\mathsf{union}(\mathsf{match}(\Gamma; M, m, a), \mathsf{match}(\Gamma, v : a; M, m, b))$
      }
      \Case{$\lambda (v : a). b$}{
        \Return $\mathsf{union}(\mathsf{match}(\Gamma; M, m, a), \mathsf{match}(\Gamma, v : a; M, m, b))$
      }
      \Other{\Return $\emptyset$}
    }
  }
\end{algorithm}